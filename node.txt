第一天实现的lru.go中的Value接口并没有实现，测试方法给了实现才可以跑的，所以在第二天的byteview.go正式给了实现了
第二天实现的getterFunc也同样没有实现，测试方法给了实现才可以跑的，所以在后面应该会给出具体实现
第二天的NewGroup方法，其实得判断一下是否已经存在，否则按照目前的写法就是覆盖了，但是又现在还没有写到缓存过期删除的操作，目前缓存是永久的，所以，我感觉后面考虑到缓存过期，我再来看看这一方面怎么修改。

之前一直在想的一个问题，结构体中有sync.mutex，但是在new结构体的时候又重来没给它赋过值，其实，在new结构体的时候，是会给sync.mutex变量赋初值的，在没有指定初始化值时会默认初始化为对应类型的零值，对应到读写锁就是读写均未加锁状态。如果是指针类型就是空指针，那就不能直接使用


./server -port=8003 -api=1  原来，怪不得怎么老是8003去请求8001的，原来是9999与8003绑定了，用户发送请求给9999，然后9999再去向8003请求，8003本地没有，就判断key是在哪个服务器上，如果是其他服务器就向其他服务器发送请求，如果是自己就调用自己的回调函数，然后缓存本地

哦哦哦，我又知道了，为什么是绑定了，因为下面是三个线程，8002和9999在同一个线程，因为api为1，其余的没有api的默认为0的，所以就相当于8002和9999在同一台服务器一样，8002相当于本地，所以9999先从8002本地获取，获取不到再根据key的哈希值看看缓存在哪一台服务器，再去对应的服务器找，找不到就从数据库找然后缓存在对应的服务器，如果是本机，就从数据库找然后缓存本地
./server -port=8002 -api=1 &
./server -port=8003  &
./server -port=8001  &

Tom和Jack是1，Sam是3，哈哈，改成8002，感觉一切都清晰了


其实，本地获取缓存和远程服务器获取缓存是不一样的，本地获取缓存是直接从存放缓存的双向链表中换取的，而远程服务器则是由本地向远程服务器发http请求，然后远程服务器再响应请求的，远程服务器也是同样的方法，先从本地缓存中找，找不到就向查找key存放的服务器，发现是自己后就调用回调函数并且缓存在本地